# 一、概述
数据库（database）简称db：就是按照某种数据结构来组织、存储、管理数据的一个软件（仓库）,简单说就是怎么存储数据，然后怎么获取存储的数据。主要学习MySQL、mongodb、redis三个。

# 二、数据库分类

## 2.1 关系型数据库
关系型数据库（mysql、oracle、sql server、db2等）用数据表存储，都是表数据，使用SQL结构化查询语言操作数据库。

**例子**
点外卖的订单数据,比如点KFC的订单数据。
| 订单号      | 姓名  |   商品名 | 商品数量 | 单价 |
| :---------- | :---: | -------: | -------: | ---: |
| 20230801001 | 张三  | 鱼香肉丝 |        2 |   10 |
| 20230801002 | 李四  |   红烧肉 |        1 |   20 |
| 20230801003 | 王五  | 鱼香肉丝 |        1 |   10 |
| 20230801004 | 赵六  |   红烧肉 |        2 |   20 |


## 2.2 非关系型数据库
非关系型数据库（nosql = not only sql ，不仅仅是SQL）、mongodb，redis等与传统的关系型数据库不同的数据库的统称。其中 mongodb 是文档型数据库，文档存储一般用类似json的格式存储，操作数据库和js的函数类似。以及key-value型数据库redis，它是用来存储cookie等。

**例子**
KFC订单的例子可能就如下所示:
```json
[
  {
    "orderId": "20230801001",
    "name": "张三",
    "goodsName": "鱼香肉丝",
    "num": 2,
    "price": 10
  },
  {
    "orderId": "20230801002",
    "name": "李四",
    "goodsName": "红烧肉",
    "num": 1,
    "price": 20
  },
  {
    "orderId": "20230801003",
    "name": "王五",
    "goodsName": "鱼香肉丝",
    "num": 1,
    "price": 10
  },
  {
    "orderId": "20230801004",
    "name": "赵六",
    "goodsName": "红烧肉",
    "num": 2,
    "price": 20
  }
]
```

## 2.3 两者比较
它们都有在命令行窗口中和GUI图新软件上操作两种方式，但是其实命令的原理是类似的。

| SQL术语/概念            | MongoDB术语/概念  |                           解释/说明 |
| :---------------------- | :---------------: | ----------------------------------: |
| database/schema(数据库) | database(数据库)  |                              数据库 |
| table(表)               | collection(集合)  |                       数据库表/集合 |
| row(行)                 |   record(记录)    |                     数据记录行/文档 |
| column(列/字段)         |     field(域)     |                         数据字段/域 |
| index(索引)             |    index(索引)    |                                索引 |
| table joins(表连接)     |                   |                表连接,MongoDB不支持 |
| primary key(主键)       | primary key(主键) | 主键,MongoDB自动将_id字段设置为主键 |

# 三、数据库操作

## 3.1 关系型数据库-MySQL

### 1 概述
关系型数据库的主要任务就是让这些表关联起来，这也就是为什么叫关系型数据库的原因。表关联起来的方式就是Schema(模式)，即Schema就是一个数据库的组织结构,也就是一个 database 数据库。(从 MySQL5.0 开始，官方文档中开始使用 schema 来代替 database 来描述 MySQL 中的数据库。但是，实际上 MySQL 中的数据库仍然可以使用 database 来称呼，两者是等价的) 数据库表列名-column 数据库表行名-row,每一行数据叫做一个记录（Record）。

所以一般是想好要存什么数据到数据库中,然后先创建数据库,再根据需求结构创建表。
建库是很简单的,在建库时可以指定数据库的编码,字符集,排序规则等信息。主要是要符合范式

**数据库设计有三大范式：**
就是数据设计的规范，以便创建高效方便独立的表。
1. 第一范式（1NF）数据表中的每一列(即每一个字段)必须是不可拆分的最小单位，确保每一列保持原子性简单说就是每一列的属性值唯一，比如name字段，属性值不能是zhangsang25，明显25可以 拆分到age字段。
2. 第二范式（2NF）满足1NF后，要求表中所有的列都必须依赖于整个主键而不是部分的键，即没有部分依赖。确保表中每一列都和主键相关。

比如说：张三写了一本书叫《张三的一生》在2020年出版了,如果设计成下面这样，选择author作者为主键就不是很符合2NF了。因为作者和出版时间不是很相关的关系，这时就需要拆分。
| 书名           | 作者   | 出版时间 |
| :------------- | :----- | :------- |
| name           | author | time     |
| 《张三的一生》 | 张三   | 2020     |

书是一张表，主键是书名
| Name           | time |
| :------------- | :--- |
| 《张三的一生》 | 2020 |


作者是一张表，外键是书名
| name           | author |
| :------------- | :----- |
| 《张三的一生》 | 张三   |

            
3. 第三范式（3NF）必须先满足2NF，要求表中的每一列只与主键直接相关而不是间接相关。即没有传递依赖确保每一列都和主键列直接相关，而不是间接相关。类似的不符合3	NF就继续拆分成多个表。

但其实现实中,建表是很方便的主要就是设计column名(即列名)，以及约定列名的数据类型、类型、约束、注释、默认值等。(这样当用户输入的数据和约定的数据类型不一样时，数据库会自动检测并报错。)


常见的约束有:
1. 主键约束: PRIMARY KEY (自带了唯一（unique）和非空（not null）的约束。)
2. 非空约束: NOT NULL (不能为空)
3. 唯一约束: UNIQUE
4. 默认约束: DEFAULT
5. 检查约束: CHECK
6. 外键约束: FOREIGN KEY

常见的数据类型有:
1. INT 存储整数
2. VARCHAR(100): 存储变长字符串，可以指定长度 
3. CHAR：定长字符串，不够的自动在末尾填充空格
4. DOUBLE：存储浮点数
5. DATE：存储日期 2023-05-27
6. TIME：存储时间 10:13
7. DATETIME：存储日期和时间 2023-05-27 10:13:00
8. TIMESTAMP：时间戳，记录时间的变化，自动记录当前时间，不能手动修改。

比如有一个订票系统数据库 order_db,它有用户表,订单表,航班表三个表.

用户表 user_table,表结构如下:
| 字段名     | 类型         | 说明     |
| :--------- | :----------- | :------- |
| userId     | varchar(255) | 用户id   |
| name       | varchar(255) | 姓名     |
| age        | int          | 年龄     |
| sex        | varchar(255) | 性别     |
| phone      | varchar(255) | 手机号   |
| email      | varchar(255) | 邮箱     |
| createTime | datetime     | 创建时间 |
| updateTime | datetime     | 修改时间 |


订单表 order_table,表结构如下:
| 字段名     | 类型         | 说明     |
| :--------- | :----------- | :------- |
| orderId    | varchar(255) | 订单号   |
| name       | varchar(255) | 姓名     |
| goodsName  | varchar(255) | 商品名   |
| num        | int          | 商品数量 |
| price      | int          | 单价     |
| totalPrice | int          | 总价     |
| createTime | datetime     | 创建时间 |
| updateTime | datetime     | 修改时间 |


航班表 flight_table,表结构如下:
| 字段名     | 类型          | 说明     |
| :--------- | :------------ | :------- |
| flightId   | varchar(255)  | 航班号   |
| name       | varchar(255)  | 姓名     |
| airLine    | varchar(255)  | 航空公司 |
| from       | varchar(255)  | 出发地   |
| to         | varchar(255)  | 目的地   |
| price      | decimal(10,2) | 价格     |
| createTime | datetime      | 创建时间 |
| updateTime | datetime      | 修改时间 |

### 2 单表操作
SQL：结构化查询语言的简称(structured query language)，是一种数据库查询和程序设计语言，作用就是用来操作关系型数据库的。我们直接写 SQL 语句,不多bb。实际使用 GUI 工具操作数据库更加方便,比如 Navicat 等。
**注意：**不能使用sql语句的关键字，为了避免错误可以使用反引号包起来。标准sql语句是大写的，但是小写也支持。

```sql
/*显示当前数据库的版本号*/
select version();
-- 创建一个新的数据库，当然一般为了防止冲突都会先删除旧的数据库。
drop database if exists teststudy;
-- 创建数据库
create database teststudy;
create schema teststudy;
-- 也可以组合使用创建时判断是否存在
create database if not exists teststudy;
-- 使用(进入)指定数据库
use teststudy;
-- 显示当前数据库所有的表
show tables;

-- 创建一个记录学生信息的 student 表
-- 创建表之前先删除
drop table if exists `student`;
CREATE TABLE `student` (
  PRIMARY KEY (`id`)
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID', -- 主键，设置自动增长
  `name` varchar(45) NOT NULL COMMENT '名字',
  `age` int DEFAULT NULL COMMENT '年龄',
  `gender` int DEFAULT NULL COMMENT '性别',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
	`class` VARCHAR(50) NOT NULL COMMENT '班级名',
  `score` INT NOT NULL COMMENT '分数',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `status` int DEFAULT '0' COMMENT '是否删除',
) CHARSET=utf8mb4 engine = innodb comment = '学生信息表';
-- 删除表
drop table student;

-- 添加数据
INSERT INTO `student` (`name`, `age`, `gender`, `email`, `class`, `score`, `create_time`) 
VALUES 
('张三', '23', '1', 'bbb@qq.com','一班', 88, '2023-05-27 10:50:00'),
('李四', '13', '2', 'ss@163.com','二班', 67,'2023-01-27 17:12:10'),
('王五', '45', '1', 'HJT@qq.com','四班', 84,'2023-05-27 10:50:00'),
('马六', '33', '2', 'bbb@qq.com','五班', 90,'2023-05-27 10:50:00'),
('鬼脚七', '38', '1', 'bbb@qq.com','三班', 78,'2023-05-27 10:50:00'),
('孙八', '53', '1', 'bbb@qq.com','一班',96, '2023-05-27 10:50:00'),
('张九', '22', '2', 'sdsd@dd.com','六班', 77, '2025-08-07 15:03:39');
-- 查询所有数据
SELECT * FROM `student`;
-- 查询指定列名
SELECT NAME,age,class,score FROM student;
-- 给列名指定别名
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student;
-- 带条件的，通过 where
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE age >= 24;
-- 条件可以是 and 连接的多个(交集)
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE age <= 24 AND score > 80 AND gender = 1;
-- 或者是 or 连接的多个(并集)
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE age <= 24 OR score > 80 OR gender = 1;
-- 条件不确定可以用 LIKE 做模糊查询。以张开头的
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE NAME LIKE '张%';
-- 条件不确定可以用 LIKE 。以三结尾的
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE NAME LIKE '%三';
-- 条件不确定可以用 LIKE 做模糊查询。包含字符三的
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE NAME LIKE '%三%';
-- 通过 in 来指定一个集合、 not in 不在一个集合
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE class IN ('一班','二班');
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE class NOT IN ('一班','二班');
-- 通过 between and 来指定一个区间
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student WHERE age BETWEEN 18 AND 22;
-- 返回的数量太多，可以分页返回，这个是通过 limit 实现的,没有就是空.
select * from student limit 0,5;
-- 分页查询，每页显示5条数据，查询第2页
select * from student limit 5,5;
-- 分页查询，每页显示5条数据，查询第3页
select * from student limit 10,5;
-- 通过 order by 来指定排序的列-不指定时默认升序ASC、降序DESC
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student ORDER BY score ASC;
SELECT NAME as '姓名',age as '年龄',class as '班级',score as '分数' FROM student ORDER BY score DESC;
-- 分组统计各班平均分
SELECT class as 班级, AVG(score) AS 平均成绩 FROM student GROUP BY class ORDER BY 平均成绩 DESC;
-- 分组统计各班总分
SELECT class as 班级, SUM(score) AS 总成绩 FROM student GROUP BY class ORDER BY 总成绩 DESC;
-- 统计每班人数
select class, count(*) as count from student group by class;
-- 分组统计之后还可以做进一步的过滤，用 having,平均分大于90的班级
SELECT class,AVG(score) AS avg_score FROM student GROUP BY class HAVING avg_score > 90;

-- 像 AVG、SUM、COUNT 这些是内置函数,常见的如下
SELECT MAX(score) AS 最高分, MIN(score) AS 最低分, AVG(score) AS 平均分, SUM(score) AS 总分, COUNT(*) AS 总人数 FROM student;

-- 修改
UPDATE `student` SET `email` = 'xxx@qq.com' WHERE (`id` = '4');
-- 删除
DELETE FROM `student` WHERE (`id` = '5');





```

### 3 多表操作
单表的操作是很简单的,关系型数据库的关键是关系,数据库中会有很多的表，分别存储不同的信息，比如学生表存学生的信息、老师表存老师的信息，班级表存班级的信息。这些表之间不是孤立的，有着一定的关系。
比如学生和学生卡之间是一对一关系，一个学生只能有一个学生卡，一个学生卡只能属于一个学生。
比如班级和学生之间是一对多的关系，也就是一个班级可以有多个学生。
比如班级和老师之间是多对多的关系，也就是一个班级可以有多个老师，一个老师也可以教多个班级。

数据库如何存储这种关系呢？这种是通过外键来进行约束,但是实际项目上是通过中间表实现的。
primary key 就是自己表中一个字段的唯一标识，称为主键。
其它表引用这个主键称为外键，外键也是一个限制。 

#### 1 一对一关系
学生和学生卡,前面我们已经实现了学生表的建立,这里我们再建立一个学生卡表,并建立关系。
学生表的主键是id,通过id确认唯一对应的一个学生。
学生卡表想查找学生也是通过这个id来查找,所以多一列用来存储学生id,列名叫student_id,通过这个id 就可以实现这种一对一的关联。此时这个student_id列就是外键。而学生表叫主表,使用外键引用它的 student_card 表是从表。

**级联方式**也就是主表修改 id 或者删除的时候，从表怎么做,可选值有四种。
格式: ON DELETE NO ACTION ON UPDATE NO ACTION 

| 操作      | 描述                                                                             |
| --------- | -------------------------------------------------------------------------------- |
| NO ACTION | mysql 里 NO ACTION 等同于 RESTRICT。                                             |
| CASCADE   | 主表主键更新，从表关联记录的外键跟着更新，主表记录删除，从表关联记录删除(慎用)   |
| RESTRICT  | 只有没有从表的关联记录时，才允许删除主表记录或者更新主表记录的主键 id            |
| SET NULL  | 主表主键更新或者主表记录删除，从表关联记录的外键​自动设为null​（需字段允许NULL） |
CASCADE（关联删除或更新），SET NULL（关联外键设置为 null），RESTRICT 或者 NO ACTION（没有从表的关联记录才可以删除或更新）

**关联查询:** 关联查询使用 JOIN ON 来实现,也就是连接 student 和 student_card 表，关联方式是 student.id = student_card.student_id，也就是 student_card 表中的外键关联 student 表的主键。


-- 这是最基础的关联查询,查询A表和B表的所有字段,关联条件是A表的id等于B表的id。
SELECT * FROM A表(主表) JOIN B表(从表) ON A表.id(主键) = B表.id(外键);  
SELECT * FROM student JOIN student_card ON student.id = student_card.student_id;

**关联查询分类:**我们使用的 JOIN ON 其实默认是 INNER JOIN ON，相当于这么写
SELECT * FROM A表(主表,左表) INNER JOIN B表(从表,右表) ON A表.id(主键) = B表.id(外键);
在 FROM 后的是左表，JOIN 后的表是右表。
1. INNER JOIN 是只返回两个表中能关联上的数据,也就是说只有当左表和右表都有数据时且匹配时,才会返回数据。
2. LEFT JOIN 是额外返回左表中没有关联上的数据,也就是说左表中的数据都会返回,右表中没有关联上的数据返回NULL。
3. RIGHT JOIN 是额外返回右表中没有关联上的数据,也就是说右表中的数据都会返回,左表中没有关联上的数据返回NULL。

-- 左查询:查询所有学生,如果有学生卡,则查询学生卡的信息,如果没有,则查询null
SELECT * FROM student LEFT JOIN student_card ON student.id = student_card.student_id;
-- 右查询:查询所有学生卡,如果有学生,则查询学生信息,如果没有,则查询null
SELECT * FROM student_card RIGHT JOIN student ON student_card.student_id = student.id;

一般情况，还是用默认的 JOIN ON 比较多，也就是 INNER JOIN。

**示例代码：**
```sql
-- 学生信息表相关
drop table if exists `student`;
CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID', -- 主键，设置自动增长
  `name` varchar(45) NOT NULL COMMENT '名字',
  `age` int DEFAULT NULL COMMENT '年龄',
  `gender` int DEFAULT NULL COMMENT '性别',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
	`class` VARCHAR(50) NOT NULL COMMENT '班级名',
  `score` INT NOT NULL COMMENT '分数',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `status` int DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)
) CHARSET=utf8mb4 engine = innodb comment = '学生信息表';

-- 学生卡表相关
drop table if exists `student_card`;
CREATE TABLE `student_card` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `card_number` varchar(255) DEFAULT NULL COMMENT '卡号',
  `student_id` int DEFAULT NULL COMMENT '学生ID',
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),  -- 主键移至字段定义后
  INDEX `student_id_idx` (`student_id`),  -- 修正索引命名
  CONSTRAINT `fk_student_id` FOREIGN KEY (`student_id`) 
    REFERENCES `student` (`id`) 
    ON DELETE NO ACTION  -- 明确指定动作类型
    ON UPDATE NO ACTION
    -- 添加一个外键约束并指定引用的表和字段,并设置主表数据 update 或者 delete 的时候，从表怎么办
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生卡表';
-- 插入数据
INSERT INTO `student_card` (`student_id`, `card_number`, `create_time`, `update_time`) VALUES
(1, '123456', '2023-01-01 00:00:00', '2023-01-01 00:00:00'),
(2, '654321', '2023-01-02 00:00:00', '2023-01-02 00:00:00'),
(3, '987654', '2023-01-03 00:00:00', '2023-01-03 00:00:00'),
(4, '456789', '2023-01-04 00:00:00', '2023-01-04 00:00:00'),
(5, '321987', '2023-01-05 00:00:00', '2023-01-05 00:00:00'),
(6, '789456', '2023-01-06 00:00:00', '2023-01-06 00:00:00'),
(7, '135792', '2023-01-07 00:00:00', '2023-01-07 00:00:00');
-- 关联查询:注意查询结果和ON后面的条件顺序无关,和连表顺序有关。
SELECT * FROM student JOIN student_card ON student.id = student_card.student_id;
SELECT * FROM student JOIN student_card ON student_card.student_id = student.id ;
SELECT * FROM student_card  JOIN student  ON student_card.student_id = student.id ;
SELECT * FROM student_card  JOIN student  ON student.id = student_card.student_id;
-- 也可以指定查询字段
SELECT student.id, student.name, student_card.card_number , student_card.id as card_id FROM student JOIN student_card ON student.id = student_card.student_id;
-- 左查询:查询所有学生,如果有学生卡,则查询学生卡的信息,如果没有,则查询null
SELECT * FROM student LEFT JOIN student_card ON student.id = student_card.student_id;
-- 右查询:查询所有学生卡,如果有学生,则查询学生信息,如果没有,则查询null
SELECT * FROM student_card RIGHT JOIN student ON student_card.student_id = student.id;


```

#### 2 一对多关系
一对多关系在生活中随处可见：
一个班级可以有多个学生，而每个学生只属于一个班级。
一个作者可以写多篇文章，而每篇文章只属于一个作者。

它和一对一关系的数据表设计,操作基本是一样的,有一个区别是级联关系一般设置为 SET NULL,因为一般学生走了班级还在。
它和一对一没啥本质的区别。
**示例代码：**
```sql
-- 创建班级信息表
drop table if exists `class_info`;
CREATE TABLE `class_info` (
  id INT NOT NULL AUTO_INCREMENT  COMMENT 'ID',
  class_name VARCHAR(255) NOT NULL COMMENT '班级名称',
  class_level VARCHAR(255) NOT NULL COMMENT '班级等级',
  head_teacher VARCHAR(255) NOT NULL COMMENT '班主任',
  class_desc VARCHAR(255) NOT NULL COMMENT '班级描述',
  create_time datetime NOT NULL COMMENT '创建时间',
  status int DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)

)CHARSET=utf8mb4 engine = innodb comment = '班级信息表';
-- 添加信息
insert into class_info(class_name,class_level,head_teacher,class_desc,create_time) values
('一班','重点班','王晓燕','重点文科班','2020-01-01 00:00:00'),
('二班','重点班','李思思','重点理科班','2020-01-01 00:00:00'),
('三班','实验班','张博文','实验班的客服经理世界','2020-01-01 00:00:00'),
('四班','普通班','那瓦','普通班的客服经理世界','2020-01-01 00:00:00'),
('五班','普通班','陈丽娟','普通班的客服经理世界','2020-01-01 00:00:00'),
('六班','普通班','张三','普通班的客服经理世界','2020-01-01 00:00:00'),
('七班','普通班','陆挺','普通班的客服经理世界','2020-01-01 00:00:00');
-- 我们修改student表结构,也可以使用图形工具操作,或者使用sql语句。
drop table if exists `student`;
CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID', -- 主键，设置自动增长
  `name` varchar(45) NOT NULL COMMENT '名字',
  `age` int DEFAULT NULL COMMENT '年龄',
  `gender` int DEFAULT NULL COMMENT '性别',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
  `class_id` int DEFAULT NULL COMMENT '班级ID',
  `score` INT NOT NULL COMMENT '分数',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `status` int DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)
  INDEX `class_id_idx` (`class_id`)
  CONSTRAINT `fk__class_id` FOREIGN KEY (`class_id`) REFERENCES `class_info` (`id`) ON DELETE SET NULL ON UPDATE SET NULL


) CHARSET=utf8mb4 engine = innodb comment = '学生信息表';
-- 或者一条一条命令修改
-- 删除class列
ALTER TABLE `student` DROP COLUMN `class`;
-- 添加class_id列
ALTER TABLE `student` ADD COLUMN `class_id` INT NULL COMMENT '班级ID';
-- 设置索引
ALTER TABLE `student` ADD INDEX `class_id_idx` (`class_id`);
-- 设置外键
ALTER TABLE student ADD CONSTRAINT fk__class_id foreign key (class_id) references class_info(id) ON DELETE SET NULL ON UPDATE SET NULL;
-- 这时候就可以关联查询了
select * from student join class_info on student.class_id = class_info.id;
-- 指定字段
select student.id, student.name,  student.score, class_info.class_name, class_info.class_level,class_info.head_teacher from student join class_info on student.class_id = class_info.id;
-- 左联查询
select student.id, student.name,  student.score, class_info.class_name, class_info.class_level,class_info.head_teacher from student left join class_info on student.class_id = class_info.id;
-- 右联查询
select student.id, student.name,  student.score, class_info.class_name, class_info.class_level,class_info.head_teacher from student right join class_info on student.class_id = class_info.id;


```

#### 3 多对多关系
多对多关系在生活中也随处可见：
一篇文章可以有多个标签，一个标签可以多篇文章都有。
一个学生可以选修多门课程，一门课程可以被多个学生选修。
一个用户可以有多个角色，一个角色可能多个用户都有。
多对多关系就无法像另外两个一样设置外键来实现了,而是通过中间表来串联。
中间表一般包含两个字段,分别是两个表的外键,用来关联两个表。同时中间表的级联方式要设置为 CASCADE 级联，这个是固定的。
这时不管是哪个表删除更新,中间表都会改变,但是不会影响到另一个表。

三个表如何操作呢?其实还是使用 join 来实现,这时候可以在表名后面加一个缩写的表名方便使用。需要注意on后面的条件顺序对结果没影响。

关联查询的语法:
select * from table1 t1 join 中间表 m1 on t1.id = m1.t1_id join table2 t2 on t2.id = m1.t2_id;

**示例代码：**
```sql
-- 创建课程表
drop table if exists course;
create table course(
    id INT NOT NULL AUTO_INCREMENT  COMMENT 'ID',
    course_name varchar(255) not null comment '课程名称',
    course_desc varchar(255) comment '课程描述',
    create_time datetime not null comment '创建时间',
    status int default '0' comment '是否删除',
    primary key (id)
)CHARSET=utf8mb4 engine = innodb comment='课程表';
-- 初始化数据
insert into course(course_name,course_desc,create_time) values
('现代汉语','现代汉语（Modern Chinese）既是一种语言，又是一门学科，有广狭二义，广义的现代汉语指五四运动后汉民族所使用的语言，它不仅包括现代标准汉语（普通话），而且包括汉语各方言，','2019-07-01 00:00:00'),
('C语言程序设计','C语言程序设计（C Language Programming）是一种计算机编程语言，由Dennis Ritchie于1972年在贝尔实验室开发。它是一种通用的、静态类型的、编译式的、过程式的、 imperatively concurrent 语言。','2019-07-01 00:00:00'),
('网络工程','网络工程（Network Engineering）是一种工程学科，它涉及到设计、构建、维护和管理计算机网络。它包括网络架构、协议、设备、软件和安全等方面。','2019-07-01 00:00:00'),
('数据库原理','数据库原理（Database Theory）是一种研究数据库系统的理论基础，它涉及到数据库的设计、实现、管理和维护等方面。','2019-07-01 00:00:00'),
('数据结构','数据结构（Data Structure）是计算机科学中研究数据组织、存储和操作的学科。它关注数据的逻辑结构、物理存储结构以及数据的操作算法。','2019-07-01 00:00:00');
-- 创建中间表
drop table if exists student_course;
CREATE TABLE `student_course` (
    `student_id` INT NOT NULL COMMENT '学生ID',
    `course_id` INT NOT NULL COMMENT '课程ID',
    PRIMARY KEY (`student_id`, `course_id`), 
    INDEX `idx_course_id` (`course_id`),
    INDEX `idx_student_id` (`student_id`),
    -- 修改外键约束名称，确保全局唯一
    CONSTRAINT `fk_student_course_student_id` 
        FOREIGN KEY (`student_id`) REFERENCES `student`(`id`) 
        ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT `fk_student_course_course_id` 
        FOREIGN KEY (`course_id`) REFERENCES `course`(`id`) 
        ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生课程中间表';
-- 初始化数据
-- 初始化数据
insert into student_course(student_id,course_id) values
(1,1),
(1,2),
(1,3),
(2,5),
(2,4),
(3,1),
(3,4),
(3,3),
(4,1),
(4,5),
(4,4),
(5,3),
(5,4),
(6,1),
(6,5),
(6,3),
(6,4),
(7,5),
(7,3),
(7,4),
(8,1),
(8,2),
(8,3),
(8,4),
(8,5);
-- 关联查询,还是使用join 不过是三张表。
select * from student s join student_course sc on s.id = sc.student_id join course c on sc.course_id = c.id;
-- 指定查询条件 -查学生id = 1的选了哪些课程
select * from student s join student_course sc on s.id = sc.student_id join course c on sc.course_id = c.id where s.id = 1;
-- 选了课程id=1的学生有哪些
select s.name,s.age,s.score,c.course_name,c.course_desc from student s join student_course sc on s.id = sc.student_id join course c on sc.course_id = c.id where c.id = 1;
-- 选了课程id=1的学生有哪些,并按成绩排序
select s.name,s.age,s.score,c.course_name,c.course_desc from student s join student_course sc on s.id = sc.student_id join course c on sc.course_id = c.id where c.id = 1 order by s.score desc;

```

### 4 子查询
sql 可以嵌套 sql，也就是子查询。还是以学生表为例，如果要查询学生表中成绩最高的学生的姓名和班级名称。就要分成两个 sql 语句,先查最高分,再查询这个分数是哪个学生的。也就是将一个sql 语句的结果作为另一个 sql 语句的查询条件。
此外，子查询还有个特有的语法 EXISTS、NOT EXISTS,当子查询有返回结果的时候成立，没有返回结果的时候不成立。子查询不止 select 里可以用，insert、update、delete 语句同样可以。

```sql
-- 查询最高分的学生和所在班级信息
-- 先从学生表中查最高分
select max(score) from student; -- 96
select s.name, from student s join class_info c on s.class_id = c.id where s.score = 96;
-- 子查询将两个sql语句合二为一
select s.name, s.score,s.gender, c.class_name,c.class_desc,c.class_level from student s join class_info c on s.class_id = c.id where s.score = (select max(score) from student);
-- 查询成绩高于全校平均成绩的学生记录
SELECT * FROM student WHERE score > (SELECT AVG(score) FROM student);
-- EXISTS
SELECT name FROM student WHERE EXISTS (SELECT * FROM class_info WHERE class_info.id = student.class_id);
-- NOT EXISTS
SELECT name FROM student WHERE NOT EXISTS (SELECT * FROM class_info WHERE class_info.id = student.class_id);
--  insert + select 结合
INSERT INTO student (name, age, score) SELECT name, age, score FROM student WHERE score > (SELECT AVG(score) FROM student);
-- update + select 结合
UPDATE student SET age = 18 WHERE id IN (SELECT id FROM student WHERE score > (SELECT AVG(score) FROM student));
-- delete + select 结合
DELETE FROM student WHERE id IN (SELECT id FROM student WHERE score > (SELECT AVG(score) FROM student));

```

### 5 综合练习
一个基于电商场景的MySQL综合练习设计，有三张表:客户表、订单表、商品表。一个客户可以有多个订单，一个订单可以有多个商品。一个商品可以属于多个订单。所以客户-订单是一对多关系、订单-商品是多对多关系。

客户表包含字段:客户id、客户名称、联系电话、邮箱、客户地址、注册日期。
| 字段名   | 类型         | 说明     |
| -------- | ------------ | -------- |
| 客户id   | int          | 主键     |
| 客户名称 | varchar(255) | 客户名称 |
| 联系电话 | varchar(255) | 联系电话 |
| 邮箱     | varchar(255) | 邮箱     |
| 客户地址 | varchar(255) | 客户地址 |
| 注册日期 | date         | 注册日期 |


订单表包含字段:订单id、客户id、订单日期、订单总金额。
| 字段名     | 类型          | 说明       |
| ---------- | ------------- | ---------- |
| 订单id     | int           | 主键       |
| 客户id     | int           | 客户id     |
| 订单日期   | date          | 订单日期   |
| 订单总金额 | decimal(10,2) | 订单总金额 |


商品表包含字段:商品id、商品名称、商品类别、商品单价、库存。
| 字段名   | 类型          | 说明     |
| -------- | ------------- | -------- |
| 商品id   | int           | 主键     |
| 商品名称 | varchar(255)  | 商品名称 |
| 商品类别 | varchar(255)  | 商品类别 |
| 商品单价 | decimal(10,2) | 商品单价 |
| 库存     | int           | 库存     |

商品订单中间表:id、关联订单id、商品id、购买数量
| 字段名   | 类型 | 说明     |
| -------- | ---- | -------- |
| id       | int  | 主键     |
| 订单id   | int  | 订单id   |
| 商品id   | int  | 商品id   |
| 购买数量 | int  | 购买数量 |




需求问题:
需求 1: 查询每个客户的订单总金额
需求 2: 查询每个客户的订单总金额，并计算其占比
需求 3：查询每个客户的订单总金额，并列出每个订单的商品清单
需求 4：查询每个客户的订单总金额，并列出每个订单的商品清单，同时只显示客户名字姓“张”的客户的记录：
需求 5:查询每个客户的订单总金额，并列出每个订单的商品清单，同时只显示订单日期在2022年1月1日到2022年1月3日之间的记录
需求 6：查询每个客户的订单总金额，并计算商品数量，只包含商品名称包含“鞋”的商品，商品名用-连接，显示前 3 条记录：
需求 7: 查询存在订单的客户
需求 8: 将王磊的订单总金额打九折
需求 9: 查询所有订单的商品明细（客户名、商品名、数量、单价、金额）
需求 10: 统计每位客户的总消费金额和订单数
需求 11: 按销量排序，找出每类商品中销量最高的产品
需求 12: 找出购买过至少2种不同类别商品的客户
需求 13: 查询库存低于20且从未被购买的商品


**SQL 语句**
```sql
-- 创建一个单独的数据练习
create database if not exists db_demo;
use db_demo;
-- 创建客户表
create table if not exists customers (
    customer_id  int primary key auto_increment COMMENT '客户ID，自增长',
    name varchar(50) NOT NULL COMMENT '客户名称，非空',
    phone varchar(255) COMMENT '联系电话',
    email varchar(100) UNIQUE NOT NULL COMMENT '邮箱',
    address varchar(255) COMMENT '客户地址',
    register_date date NOT NULL COMMENT '注册日期'
    INDEX idx_name (name)  -- 高频查询索引
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='客户信息表';
-- 创建订单表
create table if not exists orders (
    order_id int primary key auto_increment COMMENT '订单ID，自增长',
    customer_id int NOT NULL COMMENT '客户ID，非空',
    order_date date NOT NULL COMMENT '订单日期',
    total_amount decimal(10,2) NOT NULL COMMENT '订单总金额',
    INDEX idx_customer_id (customer_id) -- 高频查询索引
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE ON UPDATE CASCADE,
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单信息表';
-- 创建商品表
create table if not exists products (
    product_id int primary key auto_increment COMMENT '商品ID，自增长',
    product_name VARCHAR(100) NOT NULL COMMENT '商品名称',
    category VARCHAR(100) COMMENT '商品类别',
    price decimal(10,2) COMMENT '商品单价',
    stock int UNSIGNED DEFAULT 0 COMMENT '库存'
    INDEX idx_category_price (category, price)  -- 联合索引加速筛选
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品信息表';
-- 创建订单商品中间表
create table if not exists order_products (
    id int primary key auto_increment COMMENT '订单商品ID，自增长',
    order_id int NOT NULL COMMENT '订单ID',
    product_id int NOT NULL COMMENT '商品ID',
    quantity int NOT NULL COMMENT '购买数量',
    INDEX idx_order_id (order_id),-- 加速订单商品查询
    INDEX idx_product_id (product_id)-- 加速订单商品查询
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE CASCADE ON UPDATE CASCADE,
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单商品中间表';

-- 插入数据
-- 客户数据
INSERT INTO customers (name, phone, email, address, register_date) VALUES ('张三', '13800000001', 'zhangsan@example.com', '北京', '2022-01-01'),
('李四', '13800000002', 'lisi@example.com', '上海', '2022-01-02'),
('王五', '13800000003', 'wangwu@example.com', '广州', '2022-01-03');
-- 订单数据
INSERT INTO orders (customer_id, order_date, total_amount) VALUES (1, '2022-01-01', 1000),
(2, '2022-01-02', 2000),
(3, '2022-01-03', 3000);
-- 商品数据
INSERT INTO products (product_name, category, price, stock) VALUES ('商品A', '类别A', 100, 100, 1000),
('商品B', '类别B',  45, 200),
('商品C', '类别C',  55, 300),
('商品D', '类别A',  77, 400),
('商品E', '类别B',  45, 500),
('商品F', '类别C',  89, 600);
-- 订单商品数据
INSERT INTO order_products (order_id, product_id, quantity) VALUES (1, 1, 100),
(1, 2, 20),
(2, 3, 260),
(2, 4, 30),
(3, 5, 50),







```

### 6 事务（transaction）
当执行sql语句出错时可以使用事务完成回退的功能。START TRANSACTION 开启事务后所有的 sql 语句都可以 ROLLBACK，除非执行了 COMMIT 完成这段事务。还可以设置几个 SAVEPOINT，这样可以 ROLLBACK TO 任何一个 SAVEPOINT 的位置。当你修改多个表的时候，并且这些表的数据是有关联的时候，事务是必须的。要不全部成功，要不全部不成功。基本上，只要写增删改的 sql，那都是要开事务的。

```sql
-- 开启事务 
START TRANSACTION;
-- 执行sql语句
UPDATE order_items SET quantity=1 WHERE order_id=3;

UPDATE orders SET total_amount=200 WHERE id=3;

-- 如果修改错误需要回退数据
ROLLBACK;

-- 确定提交执行 COMMIT 这时候数据就真正被修改，不能回滚了。
COMMIT;

-- 也可以设置保存的点回退到指定位置
START TRANSACTION;

SAVEPOINT aaa;

UPDATE order_items SET quantity=1 WHERE order_id=3;

SAVEPOINT bbb;

UPDATE orders SET total_amount=200 WHERE id=3;

SAVEPOINT ccc;

-- 回滚到bbb
ROLLBACK TO SAVEPOINT bbb;
-- 回滚到ccc
ROLLBACK TO SAVEPOINT ccc;

```








### 7 视图 （VIEW）
对于复杂的查询，在多次使用后，维护是一件非常麻烦的事情，这时候就可以定义视图。视图本质就是对查询的一个封装之后可以直接重复使用。视图的作用就是简化复杂的查询，提高查询的效率。视图一般只用来做查询，因为它增删改的限制比较多。了解即可。

```sql
-- 创建视图
CREATE VIEW customer_orders AS 
    SELECT 
        c.name AS customer_name, 
        o.id AS order_id, 
        o.order_date, 
        o.total_amount
    FROM customers c
    JOIN orders o ON c.id = o.customer_id;

-- 查询视图
select * from customer_orders


```



## 3.2 非关系型数据库(文档型数据库)-MongoDB

### 1 概述
Mongodb 是由C++语言编写的、面向文档的、用于存储大量数据的、为了快速开发互联网web应用而设计的开源NoSQL数据库。官网下载安装完成后使用 GUI图形工具操作即可。所谓的文档是一种类似json的结构（就是增强的json即bson二进制的json）。

和MySQL相关常用术语比较
|   RDBMS    |      MongoDB       |
| :--------: | :----------------: |
| Table(表)  |  Collection(集合)  |
|  Row(行)   |   Document(文档)   |
| Column(列) |    Field(字段)     |
|   Joins    | Embedded documents |

1. **数据库**-用db标识当前正在使用的数据库对象。
2. **集合**–集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System）中的表table。一个集合就是一张表。集合名(类似表名)命名规则：遵循js变量命名规则基本是没问题的。
3. **文档(document)**-文档是一个键值(key-value)对(即BSON)，属性名和属性值之间用:冒号隔开，键值对之间使用,逗号隔开。
4. **字段**-文档中的名称/值对。一个文档具有零个或多个字段。字段类似于关系数据库中的列。             
5. **_id**–这是每个MongoDB文档中必填的字段。_id字段表示MongoDB文档中的唯一值。_id字段类似于文档的主键。新增数据时没有指定将会自动创建。


### 2 单集合操作
安装完成后就可以进行数据库相关操作了,其实和MySQL一样，操作数据库需要先创建数据库，再创建表，最后进行增删改查。
我们先学习一个集合的CURD操作即文档的创建、读、更新以及删除操作。

1. 新增插入数据 insert() 方法可以一次将多个文档插入到集合中，多个时传递一个数组。insertOne() 将单个文档插入集合中。insertMany()可以将多个文档插入一个集合中,传入一个数组即可。如果集合当前不存在，则插入操作将创建该集合。

2. 查询 find() 方法用于查询集合中的文档,查询的条件永远是一个对象包裹的。db.collection.find( query, projection, options )接收三个可选参数。query 查询条件-使用 {} 包裹，相当于 SQL 中的 WHERE子句。空对象 {}，表示匹配集合中的所有文档。常见：精确匹配​​：{ name: "Li Lei" }、​​范围查询​​：{ age: { $gt: 18, $lte: 25 } }（年龄大于 18 且小于等于 25）、​​逻辑运算符​​：$or: { $or: [{ age: 20 }, { major: "Math" }] }、$in: { courses: { $in: ["Programming", "Math"] } }、​​嵌套文档查询​​：{ "hobby.sports": "basketball" }。projection字段投影控制返回文档中包含或排除的字段，相当于 SQL 中的 SELECT字段列表。不传时默认返回所有字段，包含字段​​：{ name: 1, age: 1 }（返回 name和 age）​​排除字段​​：{ address: 0, score: 0 }（隐藏 address和 score）​​强制排除 _id​​：{ name: 1, _id: 0 }（不返回 _id）。查询修饰符，在find()方法后面可以继续跟方法主要是sort()、skip()、limit()、count()。排序​​：.sort({ age: -1 })（按年龄降序，1升序，-1降序）​​跳过记录​​：.skip(2)（跳过2条记录）​​限制返回记录数​​：.limit(2)（返回2条记录）​​统计记录数​​：.count()（返回记录数）​

3. 更新 update() 方法用于更新集合中的文档。db.collection.update( query, update, options )接收三个参数。query 查询条件-使用 {} 包裹，相当于 SQL 中的 WHERE子句。update 更新操作-使用 {} 包裹，相当于 SQL 中的 SET 子句。options 可选参数，用于指定更新选项。

4. 删除 delete() 方法用于删除集合中的文档。db.collection.delete( query, options )接收两个参数。query 删除条件-使用 {} 包裹，相当于 SQL 中的 WHERE 子句。options 可选参数，用于指定删除选项。

还有很多方法是可以查找修改删除同时进行的：比如 findAndModify()、findOneAndUpdate()、findOneAndDelete()、findOneAndReplace()。

**常见操作符：**
| 操作符 | 描述                                                            |
| ------ | --------------------------------------------------------------- |
| $eq    | 匹配等于指定值的值。                                            |
| $gt    | 匹配大于指定值的值。                                            |
| $gte   | 匹配大于等于指定值的值。                                        |
| $in    | 匹配数组中指定的任何值。                                        |
| $lt    | 匹配小于指定值的值。                                            |
| $lte   | 匹配小于等于指定值的值。                                        |
| $ne    | 匹配所有不等于指定值的值。                                      |
| $nin   | 不匹配数组中指定的任何值。                                      |
| $an    | 使用逻辑 AND 连接查询子句将返回与两个子句的条件匹配的所有文档。 |
| $not   | 反转查询谓词的效果，并返回与查询谓词不匹配的文档。              |
| $nor   | 使用逻辑 NOR 的联接查询子句会返回无法匹配这两个子句的所有文档。 |
| $or    | 使用逻辑 OR 连接多个查询子句会返回符合任一子句条件的所有文档。  |



```bash
# 默认使用"db"来标识数据库,注意：MongoDB 中默认的数据库为 test
$ db
# 显示当前数据库服务实例所拥有的所有的数据库。
$ show dbs
# 创建或使用数据库，不存在时会在第一次插入数据时自动创建。
$ use mongo-study
# 删除当前数据库
$ db.dropDatabase()
# 查看当前数据库的所有集合
$ show collections
# 创建一个集合
$ db.createCollection("users")
# 删除指定集合
$ db.users.drop()

# 插入文档，集合不存在时会自动创建 
$ db.users.insert({name: "张三", age: 18})
# 插入多个文档
$ db.users.insert([{name: "张三", age: 18}, {name: "李四", age: 19}])
# 插入一个文档
$ db.users.insertOne({name: "王五", age: 20})
# 插入多个文档
$ db.users.insertMany([{name: "王五", age: 20}, {name: "赵六", age: 21}])
# save方法
$ db.users.save({name: "王五", age: 20})

# 查询文档练习
$ db.inventory.insertMany([
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);
# 查询所有文档 - 对应如下SQL语句 SELECT * FROM inventory
$ db.getCollection("inventory").find({})
$ db.inventory.find({})
# 所有检索到文档中item, status, _id三个字段。
# 查询指定条件 - 对应如下SQL语句 SELECT _id, item, statuqtys from inventory;
$ db.inventory.find({}, {item: 1, qty: 1})
# 查询指定条件 - 对应如下SQL语句 SELECT * FROM inventory WHERE status = "D"
$ db.inventory.find({status: "A"})
# 使用查询操作符
# 查询指定条件 - 对应如下SQL语句 SELECT * FROM inventory WHERE status = "A" AND qty < 30
$ db.inventory.find( { status: "A", qty: { $lt: 30 } } )
# 查询指定条件 - 对应如下SQL语句 SELECT * FROM inventory WHERE status = "A" OR qty < 30
$ db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } )
# 查询指定条件 - 对应如下SQL语句 SELECT * FROM inventory WHERE status in ("A", "D")
$ db.inventory.find( { status: { $in: [ "A", "D" ] } } )
# 返回inventory集合中status等于**"A" 并且qty小于 ($lt) 30或者item** 是以p字符开头的所有文档。
# 查询指定条件 - 对应如下SQL语句 SELECT * FROM inventory WHERE status = "A" AND ( qty < 30 OR item LIKE "p%")
$ db.inventory.find( {
     status: "A",
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]
} )
# 分页
$ db.inventory.find().skip(2).limit(2)

# 更新
$ db.inventory.update( { status: "D" }, { $set: { qty: 0 } } )
# 更新指定条件的第一个文档
$ db.inventory.updateOne( { status: "D" }, { $set: { qty: 0 } } )
# 批量更新
$ db.inventory.updateMany( { status: "D" }, { $set: { qty: 0 } } )

# 删除
$ db.inventory.remove( { status: "D" } )
# 删除指定条件的第一个文档
$ db.inventory.deleteOne( { status: "D" } )
# 批量删除
$ db.inventory.deleteMany( { status: "D" } )
# 删除所有
$ db.inventory.deleteMany({})
$ db.inventory.remove({})


```

### 3 多集合操作
在MongoDB中，数据关系的实现方式与传统SQL数据库不同，主要通过​​内嵌文档（Embedding）​​ 和 ​​引用（Referencing）​​ 两种策略实现复杂关系。引用方式​​是通过外键关联另一个文档的_id，需额外查询获取关联数据。本质上和SQL得类似，区别是查询方法得不一样。在mongodb中要使用$lookup（聚合查询）来实现多集合关联查询。它是对同一数据库中的集合执行左外连接(其功能类似于 SQL 中的 LEFT JOIN)，以过滤外部集合中的文档进行处理。

**核心语法**：遍历当前集合的每个文档，用 localField 的值匹配目标集合中 foreignField值相等的文档，将匹配结果以数组形式存入 as指定的字段。无论是否匹配到数据，as字段始终存在（无匹配时为空数组 []），实现 LEFT JOIN效果，$lookup可能导致内存与计算开销增大，尤其关联大数据集时。建议在 localField和 foreignField上创建索引 


```js
{
  $lookup: {
    from: "<目标集合名>",          // 需关联的集合
    localField: "<本地字段>",      // 当前集合的关联字段
    foreignField: "<目标字段>",    // 目标集合的匹配字段
    as: "<输出数组字段名>"         // 关联结果存储的字段名（数组类型）
  }
}

```

#### 1 一对一关系
推荐使用内嵌文档​将关联数据直接嵌入主文档中，确保一次查询即可获取所有信息。
```json
// ​​内嵌文档
{
  "_id": "user123",
  "name": "张三",
  "address": {  // 内嵌地址文档
    "city": "北京",
    "street": "中关村"
  }
}
// 引用
// 用户文档
{ "_id": "user123", "name": "张三" }
// 地址文档
{ "user_id": "user123", "city": "北京", "street": "中关村" }
```
#### 2 一对多关系



#### 3 多对多关系
学生（students）与课程（courses）的关联查询（需中间集合 enrollments）
```js
// 学生文档
{ "_id": "student123", "name": "张三" }
// 课程文档
{ "_id": "course123", "name": "数学" }
// 中间集合文档（记录学生选课关系）
{ "student_id": "student123", "course_id": "course123" }
// 聚合查询
db.students.aggregate([
  {
    $lookup: {
      from: "enrollments",
      localField: "_id",
      foreignField: "studentId",
      as: "enrollments"
    }
  },
  {
    $lookup: {
      from: "courses",
      localField: "enrollments.courseId",
      foreignField: "_id",
      as: "courses"
    }
  }
]);

```



## 3.3 非关系型数据库(键值型数据库)-Redis

### 1 概述
Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value键值对形式的数据库。通常在做后端服务的时候来做缓存。优点：数据存放在内存中，读写速度非常快。缺点：内存是非常昂贵的可存储的数据量不大，且断电数据丢失。

它也是分为服务器端和客户端的，并且提供了一个 redis-cli 的命令行客户端。windows版本去官网安装下载安装即可。可以使用cli交互也可以使用可视化工具，为了方便使用可视化工具即可。注意：redis默认的端口是：6379

### 2 常见数据类型操作
redis可以缓存不同类型的数据，所以 redis 的设计是 key、value 的。并且值的类型有很多：字符串（string）、列表（list）、集合（set）、有序集合（sorted set）、哈希表（hash）、地理信息（geospatial）、位图（bitmap）等。使用set和get命令可以完成绝大部分的操作了。

```js
//  string 相关的操作
$ keys * // 查看所有的key
$ get key // 获取指定key的值
$ set key value // 设置指定key的值
$ del key // 删除指定key
$ type key // 查看指定key的类型
$ strlen key // 查看指定key的value的长度
$ incr key // 自增1
$ decr key // 自减1
$ incrby key 10 // 自增10
$ decrby key 10 // 自减10

//  list 列表相关的操作
$ lpush key value // 从左边插入一个值
$ rpush key value // 从右边插入一个值
$ lpop key // 从左边弹出（删除）一个值
$ rpop key // 从右边弹出（删除）一个值
$ lrange key 0 -1 // 查看列表所有的值
$ llen key // 查看列表的长度
$ lindex key index // 查看指定索引的值
$ lset key index value // 设置指定索引的值
$ lrem key count value // 删除指定的值，count为0表示删除所有的
$ ltrim key start end // 截取列表

// set 相关操作特点是无序并且元素不重复。只能去重、判断包含，不能对元素排序。
$ sadd key value // 向集合中添加一个值
$ smembers key // 查看集合所有的值
$ srem key value // 删除集合中的一个值
$ scard key // 查看集合的长度
$ sismember key value // 查看集合是否包含指定的值
$ sunion key1 key2 // 集合的并集
$ sinter key1 key2 // 集合的交集
$ sdiff key1 key2 // 集合的差集

// sorted set，也就是 zset 排序、去重，实现如排行榜等需求
$ zadd key score value // 添加一个元素
$ zrange key 0 -1 // 查看所有元素
$ zrange key 0 -1 withscores // 查看所有元素和分数
$ zrem key value // 删除一个元素
$ zcard key // 查看元素个数
$ zscore key value // 查看元素的分数
$ zincrby key 1 value // 增加元素的分数
$ zrangebyscore key min max // 查看分数在 min 到 max 之间的元素
$ zremrangebyscore key min max // 删除分数在 min 到 max 之间的元素
$ zrevrange key 0 -1 withscores // 查看所有元素，从大到小排序
$ zrevrangebyscore key max min withscores // 查看分数在 max 到 min 之间的元素，从大到小排序

// hash 相关操作 和 map 一样
$ hset key field value // 设置一个字段的值
$ hget key field // 获取一个字段的值
$ hmset key field1 value1 field2 value2 // 设置多个字段的值
$ hmget key field1 field2 // 获取多个字段的值
$ hkeys key // 获取所有的字段
$ hvals key // 获取所有的值
$ hlen key // 获取字段的数量
$ hdel key field // 删除一个字段
$ hexists key field // 判断是否存在一个字段

```


